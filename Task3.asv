clear; close all; clc;

% Base config
conf.audiosystem    = 'emulator';
conf.emulator_idx   = 2;        
conf.emulator_snr   = 100;

conf.nbits   = 512*2*50;       
conf.f_c     = 8000;   

% SC preamble
conf.sc.f_sym = 1000;          
conf.sc.nsyms = 500;     

% OFDM
conf.ofdm.bandwidth = 2000;    
conf.ofdm.ncarrier  = 512;     
conf.ofdm.cplen     = 256;     
conf.modulation_order = 2; 

% Audio
conf.f_s    = 48000;           
conf.bitsps = 16;

% Derived
conf.ofdm.spacing   = conf.ofdm.bandwidth/conf.ofdm.ncarrier;
conf.sc.os_factor   = conf.f_s/conf.sc.f_sym;
conf.ofdm.os_factor = conf.f_s/(conf.ofdm.ncarrier*conf.ofdm.spacing);

conf.sc.txpulse_length = 20*conf.sc.os_factor;
conf.sc.txpulse        = rrc(conf.sc.os_factor, 0.22, conf.sc.txpulse_length);

rng(0);

%% ----------------- CONSISTENCY CHECKS -----------------
bitsPerSym        = conf.modulation_order;          
N                 = conf.ofdm.ncarrier;             
bitsPerOfdmSymbol = bitsPerSym * N;                

if mod(conf.nbits, bitsPerOfdmSymbol) ~= 0
    error('conf.nbits must be a multiple of %d', bitsPerOfdmSymbol);
end

nDataOfdmSym   = conf.nbits / bitsPerOfdmSymbol;
nOfdmSymTot    = nDataOfdmSym + 1;  % +1 Trainingssymbol
fprintf('Number of OFDM data symbols: %d\n', nDataOfdmSym);

%% ----------------- GENERATE DATA & TRANSMIT ONCE -----------------
txbits = randi([0 1], conf.nbits, 1);

[txsignal, conf] = txofdm(txbits, conf);

% Padding wie in Task 1 / 2
rawtxsignal = [ zeros(conf.f_s,1) ; txsignal ; zeros(conf.f_s,1) ];
rawtxsignal = [ rawtxsignal  zeros(size(rawtxsignal)) ];

%% ----------------- Looping through the channels -----------------
channelIDs = 2:5;         

% output folder for the plots
outdir = 'plots_task3';
if ~exist(outdir, 'dir')
    mkdir(outdir);
end

SNRdB      = 100;          % high SNR for characterization
Nfft_delay = N;            % FFT length for CIR
Nfft_freq  = N;            % for frequency response

for chID = channelIDs

    fprintf('\n================ CHANNEL ID %d ================\n', chID);

    % channel parameterss
    conf.emulator_idx = chID;
    conf.emulator_snr = SNRdB;

    % send signal through channel
    rxsignal = channel_emulator(rawtxsignal(:,1), conf); 

    % rx frontend
    bitsPerSym   = conf.modulation_order;       % 2 for QPSK
    N            = conf.ofdm.ncarrier;          % 512
    Ncp          = conf.ofdm.cplen;             % 256
    fs_audio     = conf.f_s;                    % 48 kHz
    fc           = conf.f_c;                    % 8 kHz

    % Downconversion
    n = (0:length(rxsignal)-1).';
    carrier_rx = exp(-1j*2*pi*fc*n/fs_audio);
    bb_rx = rxsignal(:) .* carrier_rx;

    % Low-pass filtering
    bb_rx_filt = ofdmlowpass(bb_rx, conf, conf.ofdm.bandwidth);

    % Frame Sync 
    beginning_of_data = frame_sync_ofdm(bb_rx_filt, conf);
    start_ofdm_idx = beginning_of_data + 1;

    if start_ofdm_idx <= 0 || start_ofdm_idx > length(bb_rx_filt)
        error('Task3: start_ofdm_idx out of range (%d).', start_ofdm_idx);
    end


    ofdm_bb_os_rx = bb_rx_filt(start_ofdm_idx:end);
    ofdm_bb_rx = ofdm_rx_resampling(ofdm_bb_os_rx, conf);
    total_ofdm_len = nOfdmSymTot * (N + Ncp);

    if length(ofdm_bb_rx) < total_ofdm_len
        error('Task3: ofdm_bb_rx too short (got %d, need %d).', ...
               length(ofdm_bb_rx), total_ofdm_len);
    end

    ofdm_bb_rx = ofdm_bb_rx(1:total_ofdm_len);

    % parallel blocks
    rxBlocks = reshape(ofdm_bb_rx, N+Ncp, nOfdmSymTot);

    % remove cp
    rxNoCP = rxBlocks(Ncp+1:end, :);       % N x nOfdmSymTot

    % back to freq domain
    Z = fft(rxNoCP, N, 1);              

    %% ----- channel estimation from training symbol -----
    Z_train      = Z(:,1);                      
    trainSymFreq = conf.ofdm.trainSymFreq;       % known from tx

    H_est = Z_train ./ trainSymFreq;             % N x 1

    %% ----- 1) Power Delay Profile from H_est -----
    h_est = ifft(H_est, Nfft_delay);             % Nfft_delay x 1
    pdp   = abs(h_est).^2;
    pdp   = pdp / max(pdp + eps); % normalization -> pdp is between 0..1; eps avoids divisio
    pdp_dB = 10*log10(pdp + eps);

    delayAxis = 0:Nfft_delay-1;

    fig1 = figure;
    stem(delayAxis, pdp_dB, 'filled');
    xlabel('Tap index (sample)');
    ylabel('Normalized power [dB]');
    title(sprintf('Power Delay Profile - Channel ID %d', chID));
    grid on;
    saveas(fig1, fullfile(outdir, sprintf('pdp_chID_%d.png', chID)));

    %% ----- 2) Frequenzgang |H(f)| -----
    H_plot   = fftshift(H_est);
    fAxis    = linspace(-0.5, 0.5, Nfft_freq);
    H_dB     = 20*log10(abs(H_plot) + eps);

    fig2 = figure;
    plot(fAxis, H_dB, 'LineWidth', 1.2);
    xlabel('Normalized frequency');
    ylabel('|H(f)| [dB]');
    title(sprintf('Frequency response - Channel ID %d', chID));
    grid on;
    saveas(fig2, fullfile(outdir, sprintf('freqresp_chID_%d.png', chID)));

    %% ----- 3) RMS Delay Spread als Kennwert -----
    pdp_lin = pdp / sum(pdp);
    mu_tau  = sum(delayAxis(:) .* pdp_lin);
    tau2    = sum((delayAxis(:).^2) .* pdp_lin);
    rmsDelaySpread = sqrt(tau2 - mu_tau^2);

    fprintf('Channel %d: RMS delay spread (in taps): %.2f\n', chID, rmsDelaySpread);

end
